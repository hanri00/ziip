import java.io.*;
import java.util.*;

class Node implements Comparable<Node> {
	int len;
	int y;
	int x;
	// 중심셀과의 거리 Math.abs(중심셀y - 내y)+Math.abs(중심셀x - 내x)
	

	Node(int len, int y, int x) {
		// TODO Auto-generated constructor stub
		this.len = len;
		this.y = y;
		this.x = x;
	}

	// compareTo override해야합니다.
	public int compareTo(Node o) {
		// #1. 중심과의 거리
		if (this.len < o.len)
			return -1;
		if (this.len > o.len)
			return 1;
		// #2. y기준
		if (this.y < o.y)
			return -1;
		if (this.y > o.y)
			return 1;
		// #3. x기준
		if (this.x < o.x)
			return -1;
		if (this.x > o.x)
			return 1;
		return 0;

	}
}

class UserSolution {
	// 배양상태 기록해놓을 map->여기서 삭제 안할겁니다.
	static int map[][];
	// idx: id, val:언제죽는지? =>이걸 믿을 수 있는 데이터로 관리하면서 사용해주세요
	static int life[];
	// 실제로 이차원 배열에 기록할때 쓸 pq
	static PriorityQueue<Node> pq = new PriorityQueue<>();
	// 배양 size만큼 빈칸 있는지 확인할때 쓸 q
	static Queue<Node> q = new ArrayDeque<>();
	static int n;
	static int dy[] = {-1,1,0,0};
	static int dx[] = {0,0,-1,1};
	public void init(int N) {
		// (1,1)~(N,N)
		map = new int[N + 1][N + 1];
		life = new int[3001];
		n = N;
		return;
	}
	static Main.Result ff(int t, int y, int x, Main.Bacteria bac) {
		Main.Result ret = new Main.Result();
		pq.clear();
		int visited[][] = new int[n+1][n+1];
		pq.add(new Node(0,y,x));
		int cnt=0;
		
		visited[y][x] = 1;
		//map[y][x] = bac.id;
		while(!pq.isEmpty()) {
			Node now = pq.remove();
			cnt++;
			map[now.y][now.x] = bac.id;
			ret.col = now.x;
			ret.row = now.y;
			if(cnt == bac.size)return ret;
			for(int i=0; i<4; i++) {
				int ny = now.y +dy[i];
				int nx = now.x +dx[i];
				if(ny<1 || ny>=n+1 || nx<1 ||nx>=n+1)continue;
				if(visited[ny][nx] !=0)continue;
				if(life[map[ny][nx]] > t )continue;
				visited[ny][nx] = 1;
				pq.add(new Node(Math.abs(ny - y)+Math.abs(nx - x), ny, nx));
			}
		}
		return ret;
	}
	static boolean can(int t, int y, int x, Main.Bacteria bac) {
		int visited[][] =new int[n+1][n+1];
		q.clear();
		q.add(new Node(0, y, x));
		visited[y][x] = 1;
		int cnt=0;
		while(!q.isEmpty()) {
			Node now =q.remove();
			cnt++;
			//배양할수있는 칸이 충분하다
			if(cnt == bac.size)return true;
			for(int i=0; i<4; i++) {
				int ny = now.y + dy[i];
				int nx = now.x +dx[i];
				//바운더리 체크
				if(ny<1 || ny>=n+1 || nx<1 || nx>=n+1)continue;
				//갔던데면 가면안되고
				if(visited[ny][nx]!=0)continue;
				//다른 박테리가 이미 서식중이면 가고 안되고
				if(life[map[ny][nx]] > t)continue;
				visited[ny][nx] = 1;
				q.add(new Node(0,ny, nx));
			}
		}
		//배양할 수 있는 칸이 없다.
		return false;
	}
	public Main.Result putBacteria(int mTime, int mRow, int mCol, Main.Bacteria mBac) {
		//#1. map[mRow][mCol]에 뭐가 있는지 봐야함
		Main.Result ret = new Main.Result();
		if(life[map[mRow][mCol]] > mTime)return ret;
		if(can(mTime, mRow, mCol, mBac)) {
			//언제 죽는지 기록해 둬야함
			life[mBac.id] = mTime+ mBac.time;
			//번식을 진짜로 시켜야 함
			ret = ff(mTime, mRow, mCol, mBac);
		}
		return ret;
	}

	public int killBacteria(int mTime, int mRow, int mCol) {
		//기록된애가 죽었을 경우, 혹은 기록이 0으로 되어 있을경우
		if(life[map[mRow][mCol]] <=mTime)return 0;
		life[map[mRow][mCol]] = 0;
		return map[mRow][mCol];
	}

	public int checkCell(int mTime, int mRow, int mCol) {
		if(life[map[mRow][mCol]]<=mTime)return 0;
		return map[mRow][mCol];
	}
}